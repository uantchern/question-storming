
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Question Storming</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="module">
        import { neon } from 'https://cdn.jsdelivr.net/npm/@neondatabase/serverless@0.9.4/+esm';
        console.log("Timeline Connection: Initializing Neon...");
        // Exact connection string provided by user
        window.sql = neon('postgresql://neondb_owner:npg_0hp5ELqOfJzc@ep-lucky-silence-aij8amzl-pooler.c-4.us-east-1.aws.neon.tech/neondb?sslmode=require&channel_binding=require');
    </script>

    <style>
        :root {
            --bg-color: #0f172a;
            /* deeper slate navy */
            --text-color: #f8fafc;
            --text-muted: #94a3b8;
            --accent-color: #38bdf8;
            /* sky blue accent */
            --accent-hover: #0284c7;
            --surface-color: #1e293b;
            --surface-hover: #334155;
            --border-color: #334155;
            --error-color: #ef4444;
            --success-color: #10b981;
            --star-color: #fbbf24;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .app-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
            padding: 0 1.5rem;
        }

        .app-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 2rem 0;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 2rem;
        }

        .brand {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .brand-icon {
            color: var(--accent-color);
            width: 28px;
            height: 28px;
            fill: none;
            stroke: currentColor;
            stroke-width: 2;
            stroke-linecap: round;
            stroke-linejoin: round;
        }

        .brand h1 {
            font-size: 1.5rem;
            font-weight: 700;
            letter-spacing: -0.025em;
            margin: 0;
        }

        .reset-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: var(--surface-color);
            color: var(--text-color);
            border-color: var(--text-muted);
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding-bottom: 4rem;
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-20px);
            }

            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .fade-in {
            animation: fadeIn 0.4s ease-out forwards;
        }

        /* Forms and Inputs */
        input[type="text"],
        textarea {
            width: 100%;
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            padding: 1rem 1.25rem;
            border-radius: 12px;
            font-size: 1.125rem;
            transition: all 0.2s ease;
            font-family: inherit;
        }

        input[type="text"]::placeholder,
        textarea::placeholder {
            color: var(--text-muted);
        }

        input[type="text"]:focus,
        textarea:focus {
            outline: none;
            border-color: var(--accent-color);
            background-color: #24344d;
            box-shadow: 0 0 0 4px rgba(56, 189, 248, 0.1);
        }

        .setup-fields {
            display: grid;
            grid-template-columns: 1fr 140px;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }

        .duration-input {
            height: 100%;
            min-height: 120px;
            text-align: center;
            font-size: 2rem !important;
            font-weight: 800;
            color: var(--accent-color) !important;
            background-color: var(--surface-color) !important;
            border: 2px solid var(--border-color) !important;
            border-radius: 12px;
        }

        .duration-input:focus {
            outline: none;
            border-color: var(--accent-color);
            background-color: #24344d;
        }

        @media (max-width: 640px) {
            .setup-fields {
                grid-template-columns: 1fr;
            }

            .duration-input {
                min-height: 60px;
            }
        }

        .audit-trail-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            margin-top: 1rem;
        }

        .audit-item {
            display: flex;
            gap: 1rem;
            font-size: 0.9rem;
            padding: 0.5rem;
            border-radius: 6px;
            align-items: center;
        }

        .audit-item:nth-child(even) {
            background: rgba(255, 255, 255, 0.02);
        }

        .audit-index {
            color: var(--text-muted);
            width: 2rem;
        }

        .audit-star-tag {
            font-size: 0.6rem;
            font-weight: 900;
            background: var(--accent-color);
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
        }

        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin: 2rem 0;
        }

        .metric-box {
            background: rgba(255, 255, 255, 0.03);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 800;
            color: var(--accent-color);
            display: block;
        }

        .metric-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            color: var(--text-muted);
        }

        .report-card {
            background: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 16px;
            padding: 2rem;
            margin-top: 1rem;
        }

        .audit-btn {
            background: var(--accent-color);
            color: black !important;
            font-weight: 700;
            flex: 1.5;
        }

        .history-container {
            padding: 1rem 0;
        }

        .history-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .history-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .history-card {
            background: var(--surface-color);
            padding: 1.5rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
            cursor: default;
        }

        .history-card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 1rem;
            color: var(--text-muted);
            font-size: 0.8rem;
        }

        .history-scenario {
            font-size: 1.1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-color);
        }

        .history-preview {
            font-size: 0.9rem;
            color: var(--text-muted);
            opacity: 0.8;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .history-date {
            display: flex;
            align-items: center;
            gap: 0.35rem;
        }

        .history-badge {
            background: var(--border-color);
            color: var(--text-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .paradox-history {
            border-left: 4px solid #ff00ff !important;
        }

        .history-badge.paradox {
            background: #ff00ff;
            color: #000;
        }

        .history-count {
            color: var(--accent-color);
            font-weight: 600;
        }

        .loading-state {
            text-align: center;
            padding: 4rem;
            color: var(--text-muted);
        }

        .icon-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-muted);
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .icon-btn:hover {
            border-color: var(--accent-color);
            color: var(--accent-color);
        }

        /* Paradox Theme */
        .app-container.paradox-theme {
            --bg-color: #0d001a;
            --accent-color: #ff00ff;
            --accent-hover: #cc00cc;
            --border-color: #330066;
            --surface-color: #1a0033;
        }

        .paradox-label {
            font-size: 0.6rem;
            background: #ff00ff;
            color: black;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 8px;
            font-weight: 900;
        }

        .paradox-toggle-container {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 1rem;
            background: rgba(255, 0, 255, 0.05);
            border: 1px solid rgba(255, 0, 255, 0.2);
            border-radius: 12px;
            margin-bottom: 2rem;
        }

        .paradox-overlay {
            position: absolute;
            top: 1rem;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            width: 90%;
            pointer-events: none;
        }

        .paradox-glitch-text {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff00ff;
            color: #ff00ff;
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            font-weight: 700;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 0 15px rgba(255, 0, 255, 0.4);
        }

        .audit-constraint {
            font-size: 0.7rem;
            font-style: italic;
            color: #ff00ff;
            margin-top: 2px;
            opacity: 0.8;
        }

        .paradox-summary-section h3 {
            color: #ff00ff !important;
            border-color: rgba(255, 0, 255, 0.3) !important;
        }

        .paradox-insight-card {
            background: rgba(255, 0, 255, 0.05);
            border: 1px solid rgba(255, 0, 255, 0.2);
            padding: 1.5rem;
            border-radius: 12px;
            margin-top: 1rem;
        }

        .paradox-insight-card p {
            font-size: 1.1rem;
            color: #ff00ff;
            margin-bottom: 1rem;
        }

        .interference-stats {
            display: flex;
            gap: 2rem;
            font-size: 0.8rem;
            font-weight: 700;
            color: rgba(255, 0, 255, 0.6);
        }

        button.primary-btn {
            background-color: var(--accent-color);
            color: #fff;
            border: none;
            padding: 1rem 2rem;
            font-size: 1.125rem;
            font-weight: 600;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            width: 100%;
        }

        button.primary-btn:hover {
            background-color: var(--accent-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(2, 132, 199, 0.4);
        }

        button.primary-btn:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
            box-shadow: none !important;
        }

        /* Setup Phase */
        .setup-container {
            display: flex;
            flex-direction: column;
            gap: 2rem;
            max-width: 600px;
            margin: 0 auto;
            width: 100%;
            padding-top: 4rem;
        }

        .setup-header h2 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
            font-weight: 800;
            letter-spacing: -0.025em;
            background: linear-gradient(to right, #fff, #94a3b8);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .setup-header p {
            color: var(--text-muted);
            font-size: 1.125rem;
        }

        .input-group {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .input-group label {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        /* Storming Interface */
        .storming-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        .storming-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 2rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid var(--border-color);
        }

        .scenario-display {
            flex: 1;
            padding-right: 2rem;
        }

        .scenario-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin-bottom: 0.25rem;
        }

        .scenario-text {
            font-size: 1.25rem;
            font-weight: 600;
            line-height: 1.4;
            color: #fff;
        }

        .timer-display {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 2rem;
            font-weight: 800;
            font-variant-numeric: tabular-nums;
            color: var(--accent-color);
            background: var(--surface-color);
            padding: 0.75rem 1.25rem;
            border-radius: 12px;
            border: 1px solid var(--border-color);
        }

        .timer-display.low-time {
            color: var(--error-color);
            border-color: var(--error-color);
            animation: pulse 1s infinite alternate;
        }

        @keyframes pulse {
            from {
                box-shadow: 0 0 0 rgba(239, 68, 68, 0);
            }

            to {
                box-shadow: 0 0 15px rgba(239, 68, 68, 0.4);
            }
        }

        .input-section {
            position: sticky;
            top: 0;
            background-color: var(--bg-color);
            padding: 1rem 0 2rem;
            z-index: 10;
        }

        .question-form {
            position: relative;
            display: flex;
            gap: 1rem;
        }

        .question-input-wrapper {
            flex: 1;
            position: relative;
        }

        .submit-btn {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            color: var(--text-color);
            width: 60px;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .submit-btn:hover:not(:disabled) {
            background-color: var(--accent-color);
            border-color: var(--accent-color);
            color: white;
        }

        .validation-msg {
            position: absolute;
            top: calc(100% + 0.5rem);
            left: 0;
            color: var(--error-color);
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .questions-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            margin-top: 1rem;
        }

        .question-card {
            background-color: var(--surface-color);
            padding: 1.25rem 1.5rem;
            border-radius: 12px;
            border-left: 4px solid var(--accent-color);
            display: flex;
            align-items: flex-start;
            gap: 1rem;
            animation: slideIn 0.3s ease-out forwards;
        }

        .question-number {
            color: var(--text-muted);
            font-family: monospace;
            font-size: 1.125rem;
            font-weight: 600;
            min-width: 2rem;
        }

        .question-content {
            font-size: 1.125rem;
            color: var(--text-color);
            word-break: break-word;
        }

        /* Review Phase */
        .review-header {
            text-align: center;
            margin-bottom: 3rem;
            padding-top: 2rem;
        }

        .review-header h2 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }

        .review-header p {
            color: var(--text-muted);
            font-size: 1.125rem;
        }

        .review-stats {
            display: inline-flex;
            background: var(--surface-color);
            padding: 0.5rem 1rem;
            border-radius: 99px;
            font-weight: 600;
            color: var(--accent-color);
            margin-top: 1rem;
            border: 1px solid var(--border-color);
        }

        .review-list {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .review-card {
            background-color: var(--surface-color);
            border: 2px solid var(--border-color);
            padding: 1.25rem 1.5rem;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .review-card:hover {
            border-color: var(--surface-hover);
            background-color: var(--surface-hover);
        }

        .review-card.starred {
            border-color: var(--star-color);
            background-color: rgba(251, 191, 36, 0.05);
        }

        .star-btn {
            background: none;
            border: none;
            color: var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0.5rem;
        }

        .review-card:hover .star-btn {
            color: var(--text-muted);
        }

        .star-btn.active {
            color: var(--star-color);
            transform: scale(1.1);
        }

        .star-btn:hover {
            transform: scale(1.1);
        }

        .star-btn.active:hover {
            transform: scale(1.2);
        }

        .review-footer {
            margin-top: 3rem;
            text-align: center;
        }

        .download-btn {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            color: var(--text-color);
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .whatsapp-btn {
            background-color: #25D366;
            border: 1px solid #128C7E;
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .whatsapp-btn:hover {
            background-color: #128C7E;
            transform: translateY(-2px);
        }
    </style>
</head>

<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // --- Icons ---
        const PlayIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>
        );
        const LayoutIcon = ({ className }) => (
            <svg className={className} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>
        );
        const ClockIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>
        );
        const AlertCircleIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>
        );
        const SendIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>
        );
        const StarIcon = ({ size, fill }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill={fill} stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
        );
        const DownloadIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>
        );
        const ClipboardCheckIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="m12 8 3 3-3 3"></path><path d="m8 12 3-3 3 3"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path></svg>
        );
        const BarChartIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>
        );
        const FileTextIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><line x1="10" y1="9" x2="8" y2="9"></line></svg>
        );
        const ZapIcon = ({ size, className }) => (
            <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>
        );
        const HistoryIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"></path><path d="M3 3v5h5"></path><path d="M12 7v5l4 2"></path></svg>
        );
        const CalendarIcon = ({ size }) => (
            <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>
        );

        // --- Components ---
        function SessionSetup({ onStart, initialScenario }) {
            const [scenario, setScenario] = useState(initialScenario || '');
            const [duration, setDuration] = useState(730);
            const [isParadox, setIsParadox] = useState(false);

            const handleSubmit = (e) => {
                e.preventDefault();
                if (scenario.trim()) {
                    onStart(scenario.trim(), duration, isParadox);
                }
            };

            return (
                <div className="setup-container fade-in">
                    <div className="setup-header">
                        <h2>What's the challenge?</h2>
                        <p>Define your problem statement before the storm begins.</p>
                    </div>

                    <form onSubmit={handleSubmit} className="input-group">
                        <div className="setup-fields">
                            <div className="input-group">
                                <label htmlFor="scenario">Challenge Scenario</label>
                                <textarea
                                    id="scenario"
                                    value={scenario}
                                    onChange={(e) => setScenario(e.target.value)}
                                    placeholder="e.g., Key Word Sign is not widely known"
                                    rows={4}
                                    autoFocus
                                    required
                                />
                            </div>
                            <div className="input-group">
                                <label htmlFor="duration">Timer (s)</label>
                                <input
                                    id="duration"
                                    type="number"
                                    value={duration}
                                    onChange={(e) => setDuration(parseInt(e.target.value) || 0)}
                                    min="10"
                                    max="3600"
                                    className="duration-input"
                                />
                            </div>
                        </div>

                        <div className="paradox-toggle-container">
                            <input
                                type="checkbox"
                                id="paradox-check"
                                checked={isParadox}
                                onChange={(e) => setIsParadox(e.target.checked)}
                            />
                            <label htmlFor="paradox-check" style={{ display: 'flex', alignItems: 'center', gap: '0.5rem', cursor: 'pointer' }}>
                                <ZapIcon size={18} className={isParadox ? 'active-icon' : ''} />
                                <span>Paradox Mode (Reality Interference)</span>
                            </label>
                        </div>

                        <button
                            type="submit"
                            className="primary-btn"
                            disabled={!scenario.trim()}
                        >
                            <PlayIcon size={20} />
                            Start Storming {isParadox ? 'Singularity' : ''} ({duration}s)
                        </button>
                    </form>
                </div>
            );
        }

        const PARADOX_CONSTRAINTS = [
            "Casualty Shift: How would this succeed if the effect happened before the cause?",
            "Structural Defiance: Describe this solution in a room with five 90-degree corners.",
            "Biological Anarchy: What if humans could breathe nitrogen instead of oxygen?",
            "Logical Singularity: Formulate a question that is simultaneously true and false.",
            "Static Momentum: Imagine a solution that moves at light speed while standing still.",
            "Sisyphus Oasis: Deliver water to a thirst that is exactly P=0. The cup is a lens, the map is a trap."
        ];

        function StormingInterface({ scenario, duration, isParadoxMode, onTimeUp, initialQuestions, onUpdateQuestions }) {
            const [timeLeft, setTimeLeft] = useState(duration || 730);
            const [input, setInput] = useState('');
            const [error, setError] = useState('');
            const [constraintIndex, setConstraintIndex] = useState(0);
            const endOfListRef = useRef(null);

            useEffect(() => {
                if (timeLeft <= 0) {
                    onTimeUp(initialQuestions);
                    return;
                }

                const timerId = setInterval(() => setTimeLeft(prev => prev - 1), 1000);

                let constraintId;
                if (isParadoxMode) {
                    constraintId = setInterval(() => {
                        setConstraintIndex(prev => (prev + 1) % PARADOX_CONSTRAINTS.length);
                    }, 20000);
                }

                return () => {
                    clearInterval(timerId);
                    if (constraintId) clearInterval(constraintId);
                };
            }, [timeLeft, onTimeUp, initialQuestions, isParadoxMode]);

            useEffect(() => {
                endOfListRef.current?.scrollIntoView({ behavior: 'smooth' });
            }, [initialQuestions.length]);

            const formatTime = (seconds) => {
                const m = Math.floor(seconds / 60);
                const s = seconds % 60;
                return `${m}:${s.toString().padStart(2, '0')}`;
            };

            const validateQuestion = (text) => {
                const trimmed = text.trim();
                if (!trimmed) return false;

                if (trimmed.endsWith('?')) return true;

                const questionWords = ['who', 'what', 'where', 'when', 'why', 'how'];
                const lower = trimmed.toLowerCase();

                return questionWords.some(word => lower.startsWith(word));
            };

            const handleSubmit = (e) => {
                e.preventDefault();
                const trimmed = input.trim();

                if (!trimmed) return;

                if (!validateQuestion(trimmed)) {
                    setError('Must end with "?" or start with a question word (Who, What, Where, etc.)');
                    return;
                }

                const newQuestion = {
                    id: Date.now().toString(),
                    text: trimmed,
                    starred: false,
                    paradoxConstraint: isParadoxMode ? PARADOX_CONSTRAINTS[constraintIndex] : null
                };

                onUpdateQuestions([...initialQuestions, newQuestion]);
                setInput('');
                setError('');
            };

            return (
                <div className={`storming-container fade-in ${isParadoxMode ? 'paradox-active' : ''}`}>
                    {isParadoxMode && (
                        <div className="paradox-overlay">
                            <div className="paradox-glitch-text">
                                <AlertCircleIcon size={14} />
                                <span>CONSTRAINT: {PARADOX_CONSTRAINTS[constraintIndex]}</span>
                            </div>
                        </div>
                    )}
                    <div className="storming-header">
                        <div className="scenario-display">
                            <div className="scenario-label">Challenge</div>
                            <div className="scenario-text">{scenario}</div>
                        </div>
                        <div className={`timer-display ${timeLeft < 30 ? 'low-time' : ''}`}>
                            <ClockIcon size={24} />
                            {formatTime(timeLeft)}
                        </div>
                    </div>

                    <div className="input-section">
                        <form onSubmit={handleSubmit} className="question-form">
                            <div className="question-input-wrapper">
                                <input
                                    type="text"
                                    value={input}
                                    onChange={(e) => {
                                        setInput(e.target.value);
                                        if (error) setError('');
                                    }}
                                    placeholder={isParadoxMode ? "Fracture reality..." : "Type your question..."}
                                    autoFocus
                                    autoComplete="off"
                                />
                                {error && (
                                    <div className="validation-msg">
                                        <AlertCircleIcon size={16} />
                                        {error}
                                    </div>
                                )}
                            </div>
                            <button type="submit" className="submit-btn" disabled={!input.trim()} title="Fire question">
                                <SendIcon size={20} />
                            </button>
                        </form>
                    </div>

                    <div className="questions-list">
                        {initialQuestions.map((q, i) => (
                            <div key={q.id} className="question-card">
                                <div className="question-number">{String(i + 1).padStart(2, '0')}</div>
                                <div className="question-content">{q.text}</div>
                            </div>
                        ))}
                        <div ref={endOfListRef} />
                    </div>
                </div>
            );
        }

        function ReviewMode({ scenario, questions, isParadoxMode, onGoToAnalysis }) {
            const [localQuestions, setLocalQuestions] = useState(questions);
            const starredCount = localQuestions.filter(q => q.starred).length;

            const toggleStar = (id) => {
                setLocalQuestions(prev => prev.map(q => {
                    if (q.id === id) {
                        if (!q.starred && starredCount >= 3) return q;
                        return { ...q, starred: !q.starred };
                    }
                    return q;
                }));
            };

            const handleDownload = () => {
                const starred = localQuestions.filter(q => q.starred);
                const others = localQuestions.filter(q => !q.starred);

                let content = `Challenge: ${scenario}\n\n`;
                content += `--- TOP 3 QUESTIONS ---\n`;
                starred.forEach((q, i) => content += `${i + 1}. ${q.text}\n`);

                content += `\n--- OTHER QUESTIONS ---\n`;
                others.forEach((q, i) => content += `${i + 1 + starred.length}. ${q.text}\n`);

                const blob = new Blob([content], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `question-storm-${new Date().toISOString().slice(0, 10)}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            };

            const handleWhatsAppShare = () => {
                const starred = localQuestions.filter(q => q.starred);

                let text = `*Question Storming Results*\n\n`;
                text += `*Challenge:* ${scenario}\n\n`;
                if (isParadoxMode) text += `*Mode:* Paradox Singularity\n\n`;
                text += `*Top 3 Questions:*\n`;

                if (starred.length === 0) {
                    text += `(No questions were starred)\n`;
                } else {
                    starred.forEach((q, i) => text += `${i + 1}. ${q.text}\n`);
                }

                text += `\n_Generated by Question Storming App_`;

                const encodedText = encodeURIComponent(text);
                window.open(`https://wa.me/?text=${encodedText}`, '_blank');
            };

            if (questions.length === 0) {
                return (
                    <div className="review-header fade-in">
                        <h2>Time's Up!</h2>
                        <p>You didn't generate any questions this round.</p>
                    </div>
                );
            }

            return (
                <div className="fade-in">
                    <div className="review-header">
                        <h2>Time's Up!</h2>
                        <p>Review your brainstormed list and star your <strong>Top 3</strong> questions.</p>
                        <div className="review-stats">
                            {starredCount} / 3 Starred
                        </div>
                    </div>

                    <div className="review-list">
                        {localQuestions.map((q) => (
                            <div
                                key={q.id}
                                className={`review-card ${q.starred ? 'starred' : ''}`}
                                onClick={() => toggleStar(q.id)}
                            >
                                <div className="question-content">{q.text}</div>
                                <button
                                    className={`star-btn ${q.starred ? 'active' : ''}`}
                                    title={q.starred ? "Unstar" : "Star"}
                                >
                                    <StarIcon fill={q.starred ? "currentColor" : "none"} size={24} />
                                </button>
                            </div>
                        ))}
                    </div>

                    <div className="review-footer">
                        <div style={{ display: 'flex', gap: '0.75rem', width: '100%' }}>
                            <button onClick={handleWhatsAppShare} className="whatsapp-btn" style={{ flex: 1 }}>
                                WhatsApp
                            </button>
                            <button onClick={handleDownload} className="download-btn" style={{ flex: 1 }}>
                                Export
                            </button>
                            <button
                                onClick={() => onGoToAnalysis(localQuestions)}
                                className="primary-btn audit-btn"
                                style={{ flex: 1.5 }}
                            >
                                <ClipboardCheckIcon size={18} />
                                Audit Report
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        function SessionAnalysis({ session, onBack }) {
            const { scenario, questions, duration, isParadoxMode } = session;
            const starredQuestions = questions.filter(q => q.starred);
            const totalQuestions = questions.length;
            const qpm = (totalQuestions / (duration / 60 || 1)).toFixed(1);

            const handleDownloadReport = () => {
                let report = `QUESTION STORMING AUDIT REPORT\n==========================\nChallenge: ${scenario}\nMode: ${isParadoxMode ? 'PARADOX' : 'Standard'}\nTotal Questions: ${totalQuestions}\nStorm Density: ${qpm} q/min\n\nTOP OUTCOMES:\n`;
                starredQuestions.forEach((q, i) => report += `${i + 1}. ${q.text}\n`);
                report += `\nFULL AUDIT TRAIL:\n`;
                questions.forEach((q, i) => report += `[${i + 1}] ${q.text}${q.paradoxConstraint ? ` (Interference: ${q.paradoxConstraint})` : ''}${q.starred ? ' (STARRED)' : ''}\n`);

                const blob = new Blob([report], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const link = document.body.appendChild(document.createElement('a'));
                link.href = url;
                link.download = `audit_report_${Date.now()}.txt`;
                link.click();
                link.remove();
            };

            return (
                <div className="analysis-container fade-in">
                    <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '1.5rem', alignItems: 'center' }}>
                        <button onClick={onBack} className="back-btn"><ArrowLeftIcon size={16} /> Back</button>
                        <button onClick={handleDownloadReport} className="primary-btn"><FileTextIcon size={16} /> Export Audit</button>
                    </div>
                    <div className="report-card">
                        <h2 style={{ fontSize: '1.5rem', marginBottom: '0.5rem' }}>{scenario}</h2>
                        <div className="metrics-grid">
                            <div className="metric-box"><span className="metric-value">{totalQuestions}</span><span className="metric-label">Questions</span></div>
                            <div className="metric-box"><span className="metric-value">{qpm}</span><span className="metric-label">Q / Min</span></div>
                            <div className="metric-box"><span className="metric-value">{starredQuestions.length}</span><span className="metric-label">Starred</span></div>
                        </div>

                        {isParadoxMode && (
                            <div className="report-section paradox-summary-section">
                                <h3 style={{ color: '#ff00ff' }}>Paradox Summary</h3>
                                <div className="paradox-insight-card">
                                    <p>Reality fractured {questions.filter(q => q.paradoxConstraint).length} times.</p>
                                    <div className="interference-stats">
                                        <span>Intensity: High</span>
                                        <span>Stability: Unstable</span>
                                    </div>
                                </div>
                            </div>
                        )}

                        <h3 style={{ borderBottom: '1px solid #333', paddingBottom: '0.5rem', margin: '1rem 0' }}>Audit Trail</h3>
                        <div className="audit-trail-list">
                            {questions.map((q, i) => (
                                <div key={q.id} className="audit-item" style={{ flexDirection: 'column', alignItems: 'flex-start' }}>
                                    <div style={{ display: 'flex', gap: '1rem', width: '100%' }}>
                                        <span className="audit-index">{String(i + 1).padStart(2, '0')}</span>
                                        <span style={{ flex: 1 }}>{q.text}</span>
                                        {q.starred && <span className="audit-star-tag">STARRED</span>}
                                    </div>
                                    {q.paradoxConstraint && (
                                        <div className="audit-constraint" style={{ marginLeft: '3rem' }}>
                                            Anomaly: {q.paradoxConstraint}
                                        </div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            );
        }

        function HistoryView({ onBack }) {
            const [history, setHistory] = useState([]);
            const [error, setError] = useState(null);

            useEffect(() => {
                const fetchHistory = async () => {
                    console.log("Checking for SQL connection...");
                    if (!window.sql) {
                        console.warn("SQL interface not ready, retrying in 500ms...");
                        setTimeout(fetchHistory, 500);
                        return;
                    }
                    try {
                        console.log("Attempting to query Neon...");
                        const result = await window.sql`SELECT * FROM storm_sessions ORDER BY created_at DESC LIMIT 50`;
                        console.log("Neon query successful, received:", result.length, "items");
                        setHistory(result);
                        setError(null);
                    } catch (err) {
                        console.error("Neon Query Failed:", err);
                        setError(err.message || "Connection failed. Check your internet or if the table exists.");
                    } finally {
                        setLoading(false);
                    }
                };
                fetchHistory();
            }, []);

            const formatDate = (dateString) => {
                return new Date(dateString).toLocaleDateString(undefined, {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            };

            return (
                <div className="history-container fade-in">
                    <div className="history-header">
                        <button onClick={onBack} className="back-btn"><ArrowLeftIcon size={16} /> Back</button>
                        <h2>Storm History</h2>
                    </div>

                    {loading ? (
                        <div className="loading-state">Syncing with reality...</div>
                    ) : error ? (
                        <div className="loading-state" style={{ color: 'var(--error-color)' }}>
                            <p>DATABASE ERROR:</p>
                            <p style={{ fontSize: '0.8rem', marginTop: '0.5rem' }}>{error}</p>
                            <button onClick={() => window.location.reload()} className="primary-btn" style={{ marginTop: '1rem', padding: '0.5rem 1rem' }}>Retry Sync</button>
                        </div>
                    ) : history.length === 0 ? (
                        <div className="loading-state">No past storms found in this timeline.</div>
                    ) : (
                        <div className="history-list">
                            {history.map((item) => {
                                const qs = Array.isArray(item.questions) ? item.questions : (typeof item.questions === 'string' ? JSON.parse(item.questions) : []);
                                return (
                                    <div key={item.id} className={`history-card ${item.is_paradox ? 'paradox-history' : ''}`}>
                                        <div className="history-card-header">
                                            <div className="history-date">
                                                <CalendarIcon size={14} />
                                                {formatDate(item.created_at)}
                                            </div>
                                            {item.is_paradox && <span className="history-badge paradox">Paradox</span>}
                                            <div className="history-count">{qs.length} QUESTS</div>
                                        </div>
                                        <div className="history-scenario">{item.scenario}</div>
                                        <div className="history-preview">
                                            {qs.slice(0, 2).map((q, i) => (
                                                <div key={i}> {q.text}</div>
                                            ))}
                                            {qs.length > 2 && <div className="more-indicator" style={{ fontSize: '0.75rem', marginTop: '0.25rem' }}>... and {qs.length - 2} more</div>}
                                        </div>
                                    </div>
                                );
                            })}
                        </div>
                    )}
                </div>
            );
        }

        const APP_STATE_KEY = 'questionStormingState';

        function App() {
            const [session, setSession] = useState(() => {
                const saved = localStorage.getItem(APP_STATE_KEY);
                if (saved) {
                    try { return JSON.parse(saved); } catch (e) { }
                }
                return { phase: 'SETUP', scenario: '', questions: [], duration: 730, isParadoxMode: false };
            });
            const [dbError, setDbError] = useState(null);
            const [isSaving, setIsSaving] = useState(false);

            useEffect(() => { localStorage.setItem(APP_STATE_KEY, JSON.stringify(session)); }, [session]);

            const initDb = async () => {
                if (!window.sql) return;
                try {
                    await window.sql`
                        CREATE TABLE IF NOT EXISTS storm_sessions (
                            id SERIAL PRIMARY KEY,
                            scenario TEXT NOT NULL,
                            is_paradox BOOLEAN NOT NULL,
                            questions JSONB NOT NULL,
                            created_at TIMESTAMPTZ DEFAULT NOW()
                        )
                    `;
                    console.log("DB Initialized.");
                    return true;
                } catch (err) {
                    console.error("Init failed:", err);
                    setDbError("Initialization failed. Do you have the right table permissions?");
                    return false;
                }
            };

            const saveSessionToDb = async (sessionData) => {
                if (!window.sql || sessionData.questions.length === 0) return;
                setIsSaving(true);
                setDbError(null);

                const payload = {
                    scenario: sessionData.scenario,
                    is_paradox: sessionData.isParadoxMode,
                    questions: sessionData.questions,
                    created_at: new Date().toISOString()
                };

                try {
                    console.log("Saving Storm to Neon...", payload);
                    await window.sql`
                        INSERT INTO storm_sessions (scenario, is_paradox, questions, created_at)
                        VALUES (${payload.scenario}, ${payload.is_paradox}, ${JSON.stringify(payload.questions)}, ${payload.created_at})
                    `;
                    console.log("Neon Save Successful.");
                    setIsSaving(false);
                } catch (err) {
                    console.error("Primary save failed, trying recovery...", err);
                    const inited = await initDb();
                    if (inited) {
                        try {
                            await window.sql`
                                INSERT INTO storm_sessions (scenario, is_paradox, questions, created_at)
                                VALUES (${payload.scenario}, ${payload.is_paradox}, ${JSON.stringify(payload.questions)}, ${payload.created_at})
                            `;
                            setIsSaving(false);
                        } catch (reErr) {
                            setIsSaving(false);
                            setDbError("Sync Persistent Failure: " + reErr.message);
                        }
                    } else {
                        setIsSaving(false);
                        setDbError("Connection Blocked: " + err.message);
                    }
                }
            };

            const handleStartStorm = (scenario, duration, isParadoxMode) => setSession({ phase: 'STORMING', scenario, questions: [], duration, isParadoxMode });
            const handleTimerEnd = (questions) => {
                const updated = { ...session, phase: 'REVIEW', questions };
                setSession(updated);
                saveSessionToDb(updated);
            };
            const handleReset = () => {
                if (confirm("Reset session?")) {
                    setSession({ phase: 'SETUP', scenario: '', questions: [], duration: 730, isParadoxMode: false });
                }
            };
            const handleGoToAnalysis = (questions) => setSession((prev) => ({ ...prev, phase: 'ANALYSIS', questions }));
            const openHistory = () => setSession(prev => ({ ...prev, phase: 'HISTORY' }));

            return (
                <div className={`app-container ${session.isParadoxMode ? 'paradox-theme' : ''}`}>
                    <header className="app-header">
                        <div className="brand" onClick={handleReset} style={{ cursor: 'pointer' }}>
                            <LayoutIcon className="brand-icon" />
                            <h1>Question Storming {session.isParadoxMode && <span className="paradox-label">PARADOX</span>}</h1>
                        </div>
                        <div style={{ display: 'flex', gap: '0.5rem' }}>
                            {session.phase === 'SETUP' && (
                                <button className="icon-btn" onClick={openHistory} title="View History">
                                    <HistoryIcon size={20} />
                                </button>
                            )}
                            {session.phase !== 'SETUP' && <button className="reset-btn" onClick={handleReset}>New Session</button>}
                        </div>
                    </header>

                    <main className="main-content">
                        {isSaving && (
                            <div className="validation-msg" style={{ position: 'relative', top: 0, marginBottom: '1rem', background: 'rgba(56, 189, 248, 0.1)', color: 'var(--accent-color)', padding: '0.75rem', borderRadius: '8px', border: '1px solid var(--accent-color)' }}>
                                <ClockIcon size={16} className="active-icon" />
                                <span>Syncing storm to Neon...</span>
                            </div>
                        )}
                        {dbError && (
                            <div className="validation-msg" style={{ position: 'relative', top: 0, marginBottom: '1rem', background: 'rgba(239, 68, 68, 0.1)', padding: '0.75rem', borderRadius: '8px', border: '1px solid var(--error-color)' }}>
                                <AlertCircleIcon size={16} />
                                <span>Neon Sync Failure: {dbError}</span>
                                <button onClick={() => saveSessionToDb(session)} style={{ marginLeft: 'auto', background: 'var(--surface-color)', border: '1px solid var(--border-color)', color: 'var(--text-color)', padding: '2px 8px', borderRadius: '4px', cursor: 'pointer', fontSize: '0.7rem' }}>Retry</button>
                                <button onClick={() => setDbError(null)} style={{ marginLeft: '0.5rem', background: 'none', border: 'none', color: 'var(--text-muted)', cursor: 'pointer' }}></button>
                            </div>
                        )}
                        {session.phase === 'SETUP' && <SessionSetup onStart={handleStartStorm} initialScenario={session.scenario} />}
                        {session.phase === 'STORMING' && (
                            <StormingInterface
                                scenario={session.scenario}
                                duration={session.duration}
                                isParadoxMode={session.isParadoxMode}
                                initialQuestions={session.questions}
                                onTimeUp={handleTimerEnd}
                                onUpdateQuestions={(qs) => setSession(prev => ({ ...prev, questions: qs }))}
                            />
                        )}
                        {session.phase === 'REVIEW' && (
                            <ReviewMode
                                scenario={session.scenario}
                                questions={session.questions}
                                isParadoxMode={session.isParadoxMode}
                                onGoToAnalysis={handleGoToAnalysis}
                            />
                        )}
                        {session.phase === 'ANALYSIS' && <SessionAnalysis session={session} onBack={() => setSession(prev => ({ ...prev, phase: 'REVIEW' }))} />}
                        {session.phase === 'HISTORY' && <HistoryView onBack={handleReset} />}
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>

